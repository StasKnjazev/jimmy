use crate::data::{InstallOptions, Partition, Kernel};
use regex::Regex;

impl InstallOptions
{
    /// Create the script that applies the settings and installs the system
    pub fn generate_shellscript(&self) -> String
    {
        let part2_file = "/mnt/jimmy_part2.sh";
        let mut code = "#/bin/sh\n".to_string();
        code += "# Script automatically generated by jimmy-rs\n\n";
        code += "timedatectl set-ntp true\n\n";
        code += &self.fdisk_cmds().join("\n");
        code += "\n\n";
        code += &self.map_partitions(Partition::mkfs_cmd).join("\n");
        code += "\n\n";
        code += &self.map_partitions(Partition::mount_cmd).join("\n");
        code += "\n\n";
        code += "echo 'Y' | pacstrap /mnt ";
        code += &self.packages().join(" ");
        code += "\n\n";
        code += "genfstab -U /mnt >> /mnt/etc/fstab";
        code += "\n\n";
        // The system configuration part is a bit complicated, since we first need to create a
        // different script, put it in /mnt, run it with arch-chroot, and then delete it after
        // we're done.
        //
        // Check `https://bbs.archlinux.org/viewtopic.php?id=204252`
        code += &("cat <<EOF > ".to_owned() + part2_file);
        code += "\n";
        code += &self.chroot_script();
        code += "exit";
        code += "\n";
        code += "EOF";
        code += "\n\n";
        code += &("arch-chroot ".to_owned() + part2_file);
        code += "\n";
        code
    }

    /// Create the script that os ram frp, omsode the arch-chroot session
    fn chroot_script(&self) -> String
    {
        let mut code = "#/bin/sh\n".to_string();
        code += "# arch-chroot script automatically generated by jimmy-rs\n\n";
        code
    }

    /// Return a list of packages that need to be installed with `pacstrap` onto the new system
    fn packages(&self) -> Vec<&str>
    {
        vec![
            "base",
            match self.kernel {
                Kernel::Latest => "linux",
                Kernel::Lts => "linux-lts",
            },
            "linux-firmware",
            &self.extra,
            &self.bootloader,
            "efibootmgr",
        ]
    }

    /// Map a function `apply()` over all partitions, by associating them with their disks so that
    /// the proper file paths are used to identify them. The result of that function is added to
    /// the return value only if it's `Some()`
    fn map_partitions(&self, apply: fn(&Partition, u32) -> Option<String>) -> Vec<String>
    {
        let disks = self.unique_disks_used();

        disks.iter().map(|disk| {
            let partitions = self.partitions_on_disk(disk).into_iter();

            partitions
                .enumerate()
                .filter_map(|(idx, partition)| {
                    apply(partition, idx as u32)
                })
        })
        .flatten()
        .collect::<Vec<String>>()
    }

    /// TODO: find a way to make this function use `map_partitions()`
    /// Return the list of shell commands that create the partitions with `fdisk`
    fn fdisk_cmds(&self) -> Vec<String>
    {
        let disks = self.unique_disks_used();

        let mut cmds = Vec::new();
        for disk in disks {
            let partitions = self.partitions_on_disk(&disk);

            let mut cmd = String::from("echo -n \"g\\n");
            let mut i = 1;
            while i <= partitions.len() as u32 {
                cmd += partitions[i as usize - 1].fdisk_script_string(i).as_str();
                i += 1;
            }
            cmd += &format!("\\nw\\n\" | fdisk {} &>/dev/null", disk);
            cmds.push(cmd);
        }
        cmds
    }

    /// Return the list of all unique disks used in the configuration
    fn unique_disks_used(&self) -> Vec<String>
    {
        let mut disks: Vec<String> = self.partitions.iter()
            .map(|p| p.disk.clone())
            .collect();
        disks.sort();
        disks.dedup();
        disks
    }

    /// Given the name of a disk, return a list of all partitions that would be on it
    fn partitions_on_disk(&self, disk: &str) -> Vec<&Partition>
    {
        self.partitions
            .iter()
            .filter(|x| x.disk == disk)
            .collect()
    }
}

impl Partition
{
    /// Return the string that can be `echo`ed into `fdisk` to create this Partition
    pub fn fdisk_script_string(&self, number: u32) -> String
    {
        format!(
            // n: create new partition
            // p: primary partition
            // use partition number specified
            // next line: default first sector
            // use partition size specified in instance
            // then: change the type of the partition
            // use the partition number specified
            // change it to the type needed for the format
            r"n\np\n{}\n\n+{}\nt\n{}\n{}\n",
            number,
            &self.size,
            number,
            &self.fdisk_partition_type(),
        )
    }

    /// Return the `mkfs` command that can format this partition, or `None` if the format of the
    /// partition wasn't recognised.
    pub fn mkfs_cmd(&self, number: u32) -> Option<String>
    {
        let cmd = match self.format.as_str() {
            "ext2" => "mkfs.ext2",
            "ext3" => "mkfs.ext3",
            "ext4" => "mkfs.ext4",
            "fat32" => "mkfs.fat -F 32",
            "swap" => "mkswap",
            _ => ""
        }.to_string();
        if cmd.is_empty() { // if true, then we didn't recognise the format
            None
        } else {
            Some(cmd + " " + &self.get_partition_file(number))
        }
    }

    /// Return a shell command that mounts the given partition
    pub fn mount_cmd(&self, number: u32) -> Option<String>
    {
        if &self.format == "swap" {
            Some(format!(
                "swapon {}",
                self.get_partition_file(number),
            ))
        } else if self.mount.is_empty() {
            None
        } else {
            Some(format!(
                "mkdir -p /mnt{} && mount {} {}",
                self.mount,
                self.get_partition_file(number),
                self.mount,
            ))
        }
    }

    /// Return the path to the partition file (e.g. `/dev/sda1`, if provided `0`, for 0th
    /// partition)
    fn get_partition_file(&self, number: u32) -> String
    {
        let disk = self.disk.clone();
        let n = &(number + 1).to_string();
        // NVME naming patterns deviate from the usual
        let re = Regex::new(r"/dev/nvme\d+n\d+").unwrap();
        if re.is_match(&disk) {
            return disk + "p" + n;
        }
        disk + n
    }

    /// Return the `fdisk` partition type that should be used with the specified format
    fn fdisk_partition_type(&self) -> &str
    {
        match self.format.as_str() {
            "fat32" => "b", // W95 FAT32
            "swap" => "82", // Linux Swap
            _ => "83", // Linux
        }
    }
}
